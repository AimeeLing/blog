
# Node脚手架编写初学者教程

[完整的脚手架代码][1]

## 编写你的第一个脚手架

### 前言

随着NodeJs的崛起，现代前端工程已经变得越来越复杂。前端框架如雨后春笋。从Backbone,Ember,Knockout,Spine,Batman框架的崛起到Angular，React，Vue平分天下，我们经历太多代码风格的变革。

我们不可避免的学习新的框架，复杂的环境又让初学者很难入手。就拿React来说，我们要使用Babel,Webpack等模块辅助编译，经常我们还需要Redux,Immutable,Mocha,Jest,Antd或者其他第三方包（如eslint,lodash,moment,debug,uuid,request,co,koa等）辅助业务需求。

**目录结构越来越复杂，为了让每个项目使用的技术和目录结构统一，各大模块纷纷推出了自己的脚手架工具，比如redux-cli,create-react-app,vue-cli等。现在就让我们以any-cli为例，编写自己的脚手架工具吧。**

### 核心原理

    yoeman搭建项目需要提供yoeman-generator。yoeman-generator本质上就是一个具备完整文件结构的项目样板，用户需要手动地把这些generator下载到本地，然后yoeman就会根据这些generator自动生成各种不同的项目。

    vue-cli提供了相当丰富的选项和设定功能，但是其本质也是从远程仓库把不同的模版拉取到本地，而并非是什么“本地生成”的黑科技。

**这样看来，思路也就有了——首先建立不同的模板，然后脚手架根据用户的指令引用模板生成实际项目。**

**模板可以内置在脚手架当中，也可以部署在远程仓库。**

- 内置在脚手架中，使用`node file`操作来把项目克隆到本地。这么做的好处是不用在新开一个仓库来保存代码。尤其是有多个初始化项目时候，比如 any-cli init pc 与 any-cli init mobile分别生成两个不同的初始化项目，我们只需要一个仓库来保存代码即可，每次变更也只需要提交一次。

- 部署在远程仓库，使用`git clone ssh-url`把项目克隆到本地。这么做的好处是，每次模板有代码变更时，无需让用户本地升级脚手架。如果模板内置在脚手架里，每次模板代码变更，因为是在同一仓库，所以用户需要升级脚手架。而部署在远程仓库，我们只需要git clone即可获取最新模板。

### 整体架构
按照标准惯例，先看一下整体架构：

```flow
st=>operation: 添加/删除/罗列模板
template=>operation: 模板目录
chooseTemplate=>operation: 选择模板
initialRepositories=>operation: 初始化仓库名
clone=>operation: 克隆远程模板到本地
init=>operation: 更新模板项目名

e=>end
st->template->chooseTemplate->initialRepositories->clone->init
```

### 技术要点
#### bin
许多包有一个或多个可执行文件希望被安装到系统路径。在npm下要这么做非常容易

这需要在你的package.json中提供一个bin字段，它是一个命令名和本地文件名的映射。比如填写：
```
"bin": {
    "any": "./bin/any"
},
```
这样会把any命令和本地可执行文件./bin/any建立映射。也就是说，当你在命令行执行any命令时，会执行./bin/any可执行文件。原理如下：

- 全局安装，npm将会使用符号链接把这些文件链接到prefix/bin（mac目录是/usr/local/bin），系统的二进制命令全部在这里。

- 如果是本地安装，会链接到./node_modules/.bin/。只有在当前文件夹下面运行命令时，才会生效。

比如，要使用myapp作为命令时可以这么做：

如果你只有一个可执行文件，那么它的名字应该和包名相同，此时只需要提供这个文件路径(字符串)，比如：
```
{
    "name": "any-cli",
    "version": "1.2.5",
    "bin": "./path/to/program"
}
```
这和以下这种写法相同：

```
{
    "name": "any-cli",
    "version": "1.2.5",
    "bin": {
        "any-cli": "./path/to/program"
    }
}
```

#### npm link
+ 本地模块全局链接

    本地仓库链接到全局目录下。对于开发模块者而言，这算是最有价值的命令。比如我们开发`any-cli`模块时，需要在命令行中使用`any`来测试我们的代码（上述使用bin命令需要全局或者本地安装，但开发中没有发布，无法安装）。不要担心，使用npm link一切变得非常容易。

    比如我们`any-cli`项目package.json里，有一条命令如下:
    ```
    "bin": {
        "any": "./bin/any"
    },
    ```
    命令行中使用npm link
    ```
    $ npm link
    ```
    得到以下结果
    ```
    /usr/local/bin/any -> /usr/local/lib/node_modules/any-cli/bin/any
    /usr/local/lib/node_modules/any-cli -> /Users/lihongji/work/any-cli
    ```


    **分别进入prefix/bin与prefix/lib/node_modules（mac目录是/usr/local/bin与/usr/local/node_modules）目录下查看。我们发现里面分别多了`any`可执行文件与`any-cli`目录**。

    这样，每次本地仓库有改动时，全局命令也随之更新。我们就可以边开发边测试了。

+ 本地模块引用全局链接的本地模块
    如果你还有其他模块`any-cli-test`依赖于`any-cli`模块，你可以使用如下命令把全局`any`链接到当前模块下。
    ```
    $ cd ~/work/any-cli-test
    $ npm link any-cli # 把全局模式的模块链接到本地
    ```
    npm link test 命令会去`prefix/lib/node_modules`目录下查找 any-cli的模块，找到这个模块后把`prefix/lib/node_modules/any-cli` 的目录链接到当前`any-cli-test`目录下`./node_modules/any-cli 这个目录上来。

现在任何 test 模块上的改动都会直接映射到 test-example 上来。

#### 其他字段：engine与engineStrict
    node7.6.0开始支持async，如何保证用户本地安装node7.6.0以上版本呢

+ engine
    你可以在本地安装node特定版本：
    ```
    "engines": { "install-node": "7.6.0" }
    ```
    安装后，在本地node_modules/.bin目录下会多一个node可执行文件，这个命令只有在当前目录下执行才生效。

    你可以指定工作的node的版本：
    ```
    { "engines" : { "node" : ">=0.10.3 <0.12" } }
    ```
    并且，像dependensies一样，如果你不指定版本或者指定“*”作为版本，那么所有版本的node都可以。

    如果指定一个“engines”字段，那么npm会需要node在里面，如果“engines”被省略，npm会假定它在node上工作。

    你也可以用“engines”字段来指定哪一个npm版本能更好地初始化你的程序，如：
    ```
    { "engines" : { "npm" : "~1.0.20" } }
    ```
    **除非用户设置engine-strict标记，这个字段只是建议值。**

+ engineStrict
    如果你确定你的模块一定不会运行在你指定版本之外的node或者npm上，你可以在package.json文件中设置"engineStrict":true。它会重写用户的engine-strict设置。

#### 第三方包：pre-commit/node-config/commander/chalk

这几个包分别用来处理提交执行脚本，全局配置文件管理与命令行处理。会在代码中一一讲解。


  [1]: https://github.com/antgod/any-cli.git