
# Node脚手架编写初学者教程

[完整的脚手架代码][1]

## 编写你的第一个脚手架

### 前言

随着NodeJs的崛起，现代前端工程已经变得越来越复杂。前端框架如雨后春笋。从Backbone,Ember,Knockout,Spine,Batman框架的崛起到Angular，React，Vue平分天下，我们经历太多代码风格的变革。

我们不可避免的学习新的框架，复杂的环境又让初学者很难入手。就拿React来说，我们要使用Babel,Webpack等模块辅助编译，经常我们还需要Redux,Immutable,Mocha,Jest,Antd或者其他第三方包（如eslint,lodash,moment,debug,uuid,request,co,koa等）辅助业务需求。

**目录结构越来越复杂，为了让每个项目使用的技术和目录结构统一，各大模块纷纷推出了自己的脚手架工具，比如redux-cli,create-react-app,vue-cli等。现在就让我们以any-cli为例，编写自己的脚手架工具吧。**

### 核心原理

yoeman搭建项目需要提供yoeman-generator。yoeman-generator本质上就是一个具备完整文件结构的项目样板，用户需要手动地把这些generator下载到本地，然后yoeman就会根据这些generator自动生成各种不同的项目。

vue-cli提供了相当丰富的选项和设定功能，但是其本质也是从远程仓库把不同的模版拉取到本地，而并非是什么“本地生成”的黑科技。

**这样看来，思路也就有了——首先建立不同的模板，然后脚手架根据用户的指令引用模板生成实际项目。**

**模板可以内置在脚手架当中，也可以部署在远程仓库。**

- 内置在脚手架中，使用`node file`操作来把项目克隆到本地。这么做的好处是不用在新开一个仓库来保存代码。尤其是有多个初始化项目时候，比如 any-cli init pc 与 any-cli init mobile分别生成两个不同的初始化项目，我们只需要一个仓库来保存代码即可，每次变更也只需要提交一次。

- 部署在远程仓库，使用`git clone ssh-url`把项目克隆到本地。这么做的好处是，每次模板有代码变更时，无需让用户本地升级脚手架。如果模板内置在脚手架里，每次模板代码变更，因为是在同一仓库，所以用户需要升级脚手架。而部署在远程仓库，我们只需要git clone即可获取最新模板。

### 整体流程
按照标准惯例，先看一下整体流程（github不支持流程图Flow类型展示，好搓）

```
添加模板->输入模板名->是否有重名模板?添加成功:给出提示

删除模板->输入模板名->是否有模板?删除成功:给出提示

模板列表->列出所有模板

初始化模板-输入模板名-是否有模板?-输入模块名-克隆远程仓库到本地模块-切换分之:给出提示
```

### 技术要点
#### bin
许多包有一个或多个可执行文件希望被安装到系统路径。在npm下要这么做非常容易

这需要在你的package.json中提供一个bin字段，它是一个命令名和本地文件名的映射。比如填写：
```
"bin": {
    "any": "./bin/any"
},
```
这样会把any命令和本地可执行文件./bin/any建立映射。也就是说，当你在命令行执行any命令时，会执行./bin/any可执行文件。原理如下：

- 全局安装，npm将会使用符号链接把这些文件链接到prefix/bin（mac目录是/usr/local/bin），系统的二进制命令全部在这里。

- 如果是本地安装，会链接到./node_modules/.bin/。只有在当前文件夹下面运行命令时，才会生效。

比如，要使用myapp作为命令时可以这么做：

如果你只有一个可执行文件，那么它的名字应该和包名相同，此时只需要提供这个文件路径(字符串)，比如：
```
{
    "name": "any-cli",
    "version": "1.2.5",
    "bin": "./path/to/program"
}
```
这和以下这种写法相同：

```
{
    "name": "any-cli",
    "version": "1.2.5",
    "bin": {
        "any-cli": "./path/to/program"
    }
}
```

#### npm link
+ 本地模块全局链接

    本地仓库链接到全局目录下。对于开发模块者而言，这算是最有价值的命令。比如我们开发`any-cli`模块时，需要在命令行中使用`any`来测试我们的代码（上述使用bin命令需要全局或者本地安装，但开发中没有发布，无法安装）。不要担心，使用npm link一切变得非常容易。

    比如我们`any-cli`项目package.json里，有一条命令如下:
    ```
    "bin": {
        "any": "./bin/any"
    },
    ```
    命令行中使用npm link
    ```
    $ npm link
    ```
    得到以下结果
    ```
    /usr/local/bin/any -> /usr/local/lib/node_modules/any-cli/bin/any
    /usr/local/lib/node_modules/any-cli -> /Users/lihongji/work/any-cli
    ```


    **分别进入prefix/bin与prefix/lib/node_modules（mac目录是/usr/local/bin与/usr/local/node_modules）目录下查看。我们发现里面分别多了`any`可执行文件与`any-cli`目录**。

    这样，每次本地仓库有改动时，全局命令也随之更新。我们就可以边开发边测试了。

+ 本地模块引用全局链接的本地模块
    如果你还有其他模块`any-cli-test`依赖于`any-cli`模块，你可以使用如下命令把全局`any`链接到当前模块下。
    ```
    $ cd ~/work/any-cli-test
    $ npm link any-cli # 把全局模式的模块链接到本地
    ```
    npm link test 命令会去`prefix/lib/node_modules`目录下查找 any-cli的模块，找到这个模块后把`prefix/lib/node_modules/any-cli` 的目录链接到当前`any-cli-test`目录下`./node_modules/any-cli 这个目录上来。

现在任何 test 模块上的改动都会直接映射到 test-example 上来。

#### 其他字段：engine与engineStrict
    node7.6.0开始支持async，如何保证用户本地安装node7.6.0以上版本呢

+ engine
    你可以在本地安装node特定版本：
    ```
    "engines": { "install-node": "7.6.0" }
    ```
    安装后，在本地node_modules/.bin目录下会多一个node可执行文件，这个命令只有在当前目录下执行才生效。

    你可以指定工作的node的版本：
    ```
    { "engines" : { "node" : ">=0.10.3 <0.12" } }
    ```
    并且，像dependensies一样，如果你不指定版本或者指定“*”作为版本，那么所有版本的node都可以。

    如果指定一个“engines”字段，那么npm会需要node在里面，如果“engines”被省略，npm会假定它在node上工作。

    你也可以用“engines”字段来指定哪一个npm版本能更好地初始化你的程序，如：
    ```
    { "engines" : { "npm" : "~1.0.20" } }
    ```
    **除非用户设置engine-strict标记，这个字段只是建议值。**

+ engineStrict
    如果你确定你的模块一定不会运行在你指定版本之外的node或者npm上，你可以在package.json文件中设置"engineStrict":true。它会重写用户的engine-strict设置。

#### 第三方包：pre-commit/node-config/commander/chalk

这几个包分别用来处理提交执行脚本，全局配置文件管理与命令行处理。会在代码中一一讲解。


### 代码文件

创建`any-cli`项目
```
work$mkdir any-cli
work$cd any-cli
any-cli$git init && npm init
```
package.json内容
```
{
  "name": "any-cli",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "pub": "npm version patch && npm publish",
    "pre-commit": "eslint src"
  },
  "author": "antgod",
  "devDependencies": {
    "eslint": "^3.16.1",
    "eslint-config-airbnb": "^12.0.0",
    "eslint-plugin-babel": "^3.0.0",
    "eslint-plugin-import": "^1.6.1",
    "eslint-plugin-jsx-a11y": "^2.0.1",
    "eslint-plugin-markdown": "*",
    "eslint-plugin-react": "^6.3.0",
    "eslint-tinker": "^0.3.2",
    "pre-commit": "^1.2.2"
  },
  "dependencies": {
    "chalk": "^1.1.3",
    "child_process": "^1.0.2",
    "commander": "^2.9.0",
    "prompt": "^1.0.0"
  },
  "engines": {
    "install-node": "7.6.0"
  },
  "pre-commit": [
    "pre-commit"
  ],
  "bin": {
    "any": "./bin/any"
  },
  "license": "ISC"
}
```

- 字段bin下面配置被当做命令行可执行命令。指向/bin下面的any文件。
- 字段engines用来当前目录安装7.6.0版本node，可直接使用async函数而需要再使用co模块。
- pre-commit用来做提交前代码检查，运行pre-commit脚本，也就是eslint

在根目录下建立/bin 文件夹，创建any文件（无后缀名）。这个 /bin/any是整个脚手架的入口文件，所以我们首先对它进行编写。

```
#!/usr/bin/env node
const add = require('../src/command/add')
const list = require('../src/command/list')
const init = require('../src/command/init')
const del = require('../src/command/del')
const program = require('commander')
const { version } = require('../package')

// 定义当前版本
program
.version(version)

program.parse(process.argv)
if (!program.args.length) {
  program.help()
}
```

运行npm link(如果没有权限，请自行百度，使用chmod 777为usr/local目录添加权限)，把当前项目链接到全局。这样就可以直接在命令行使用any命令测试/bin/any下面的代码

```
any-cli@npm link
any-cli@any
```

我们继续在/bin/any中添加代码

```
// 定义使用方法
program
.command('add')
.description('add template')
.alias('a')
.action(add)

program
.command('del')
.description('Delete a template')
.alias('d')
.action(del)

program
.command('list')
.description('List all the templates')
.alias('l')
.action(list)

 program
.command('init')
.description('Generate a new project')
.alias('i')
.action(init)
```
    command用来配置any命令的参数，alias配置缩写，action配置运行什么函数。其他就不用多说了吧，程序员你懂的。

    commander 的具体使用方法在这里就不展开了，可以直接到 [官网][2] 去看详细的文档。

使用any命令，看到输出如下，证明入口文件已经编写完成了。

```
  Usage: any [options] [command]


  Commands:

    add|a    add template
    del|d    Delete a template
    list|l   List all the templates
    init|i   Generate a new project

  Options:

    -h, --help     output usage information
    -V, --version  output the version number
```

接着，我们创建src/command目录，下面分别创建刚才的4个参数所对应的文件。文件内容这里就不粘贴了，都是业务代码（分别对应增删查初始化）。代码使用了函数式编程，需要有点函数式基础。

  [1]: https://github.com/antgod/any-cli.git
  [2]: https://github.com/tj/commander.js/

