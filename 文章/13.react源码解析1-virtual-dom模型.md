深入React技术栈
第 3 章　解读 React 源码
通过前面两章，我们系统学习了 React 的基本概念、API、组件的构建方法以及高级用法，然而这背后的一切显得那么神奇而又神秘，它们到底是怎么运转的呢？

本章会通过分析 React 15.0 的源码，深入 Virtual DOM 内部的实现机制和原理，让我们一步步揭开 Virtual DOM 的神秘面纱，探索其内部的精彩世界！

3.1　初探 React 源码

在深入分析 React 源码之前，我们先大致了解一下 React 源码的组织结构，如图 3-1 所示。



图 3-1　React 源码目录

在 React 源码中，每个文件的命名风格属于字面与含义可相互解释，整体的代码结构按照 addons、isomorphic、renderers、shared、core、test 进行组织。

addons：包含一系列的工具方法插件，如 PureRenderMixin、CSSTransitionGroup、Fragment、LinkedStateMixin 等。

isomorphic：包含一系列同构方法。

shared：包含一些公用或常用方法，如 Transaction、CallbackQueue 等。

test：包含一些测试方法等。

core/tests：包含一些边界错误的测试用例。

renderers：是 React 代码的核心部分，它包含了大部分功能实现，此处对其进行单独分析。

renderers 分为 dom 和 shared 目录。

dom：包含 client、server 和 shared。

client：包含 DOM 操作方法（如 findDOMNode、setInnerHTML、setTextContent 等）以及事件方法，结构如图 3-2 所示。这里的事件方法主要是一些非底层的实用性事件方法，如事件监听（ReactEventListener）、常用事件方法（TapEventPlugin、EnterLeaveEventPlugin）以及一些合成事件（SyntheticEvents 等）。

{%}

图 3-2　React 下 renderers 源码目录

server：主要包含服务端渲染的实现和方法（如 ReactServerRendering、ReactServerRenderingTransaction 等）。

shared：包含文本组件（ReactDOMTextComponent）、标签组件（ReactDOMComponent）、DOM 属性操作（DOMProperty、DOMPropertyOperations）、CSS 属性操作（CSSProperty、CSSPropertyOperations）等。

shared：包含 event 和 reconciler。

event：包含一些更为底层的事件方法，如事件插件中心（EventPluginHub）、事件注册（EventPluginRegistry）、事件传播（EventPropagators）以及一些事件通用方法。

React 自定义了一套通用事件的插件系统，该系统包含事件监听器、事件发射器、事件插件中心、点击事件、进/出事件、简单事件、合成事件以及一些事件方法，如图 3-3 所示。

{%}

图 3-3　通用事件插件系统

reconciler：称为协调器，它是最为核心的部分，包含 React 中自定义组件的实现（ReactCompositeComponent）、组件生命周期机制、setState 机制（ReactUpdates、ReactUpdateQueue）、DOM diff 算法（ReactMultiChild）等重要的特性方法。

那么，为何说 reconciler 是 React 最为核心的部分呢？

在 Web 开发中，要将更新的数据实时反应到 UI 上，就不可避免地需要对 DOM 进行操作，而复杂频繁的 DOM 操作通常是产生性能瓶颈的原因之一。为此，React 引入了 Virtual DOM 机制。毫不夸张地说，Virtual DOM 是 React 的核心与精髓所在，而 reconciler 就是实现 Virtual DOM 的主要源码。

Virtual DOM 实际上是在浏览器端用 JavaScript 实现的一套 DOM API，它之于 React 就好似一个虚拟空间，包括一整套 Virtual DOM 模型、生命周期的维护和管理、性能高效的 diff 算法和将 Virtual DOM 展示为原生 DOM 的 Patch 方法等。

基于 React 进行开发时，所有的 DOM 树都是通过 Virtual DOM 构造的。React 在 Virtual DOM 上实现了 DOM diff 算法，当数据更新时，会通过 diff 寻找到需要变更的 DOM 节点，并只对变化的部分进行实际的浏览器的 DOM 更新，而不是重新渲染整个 DOM 树。

React 也能够实现 Virtual DOM 的批处理更新，当操作 Virtual DOM 时，不会马上生成真实的 DOM，而是会将一个事件循环（event loop）内的两次数据更新进行合并，这样就使得 React 能够在事件循环的结束之前完全不用操作真实的 DOM。例如，多次进行节点内容 A→B，B→A 的变化，React 会将多次数据更新合并为 A→B→A，即 A→A，认为数据并没有更新，因此 UI 也不会发生任何变化。如果通过手动控制，这种逻辑通常是极其复杂的。

尽管每一次都需要构造完整的 Virtual DOM 树，但由于 Virtual DOM 是 JavaScript 对象，性能极高，而对原生 DOM 进行操作的仅仅是 diff 部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到具体的 DOM 元素，而只需要关心在任意数据状态下，整个界面是如何渲染的。

那么，React 中是如何实现 Virtual DOM 机制的呢？为众人所津津乐道的 diff 算法到底有何神秘之处呢？组件的生命周期又是如何进行管理的呢？

从下一节开始，我们将通过分析 React 15.0 源码，深入研究 Virtual DOM 内部的实现机制及原理。

3.2　Virtual DOM 模型

Virtual DOM 之于 React，就好比一个虚拟空间，React 的所有工作几乎都是基于 Virtual DOM 完成的。其中，Virtual DOM 模型负责 Virtual DOM 底层框架的构建工作，它拥有一整套的 Virtual DOM 标签，并负责虚拟节点及其属性的构建、更新、删除等工作。那么，Virtual DOM 模型到底是如何构建虚拟节点，如何更新节点属性的呢？

其实，构建一套简易 Virtual DOM 模型并不复杂，它只需要具备一个 DOM 标签所需的基本元素即可：

标签名

节点属性，包含样式、属性、事件等

子节点

标识 id

示例代码如下：

{
  // 标签名
  tagName: 'div',
  // 属性
  properties: {
    // 样式
    style: {}
  },
  // 子节点
  children: [],
  // 唯一标识
  key: 1
}
Virtual DOM 模型当然不止于此，却也离不开这些基础元素。现在就让我们揭下它的神秘面纱，一探究竟吧！

Virtual DOM 中的节点称为 ReactNode，它分为3种类型 ReactElement、ReactFragment 和 ReactText。其中，ReactElement 又分为 ReactComponentElement 和 ReactDOMElement。

下面是 ReactNode 中不同类型节点所需要的基础元素：

type ReactNode = ReactElement | ReactFragment | ReactText;

type ReactElement = ReactComponentElement | ReactDOMElement;

type ReactDOMElement = {
  type : string,
  props : {
    children : ReactNodeList,
    className : string,
    etc.
  },
  key : string | boolean | number | null,
  ref : string | null
};

type ReactComponentElement<TProps> = {
  type : ReactClass<TProps>,
  props : TProps,
  key : string | boolean | number | null,
  ref : string | null
};

type ReactFragment = Array<ReactNode | ReactEmpty>;

type ReactNodeList = ReactNode | ReactEmpty;

type ReactText = string | number;

type ReactEmpty = null | undefined | boolean;
那么，Virtual DOM 模型是如何根据这些节点类型来创建元素的呢？

3.2.1　创建 React 元素

在 1.2 节里，我们介绍过 JSX 的语法，现在先来回顾下它的用法。下面是一段 JSX 与编译后的 JavaScript：

const Nav, Profile;

// 输入（JSX）：
const app = <Nav color="blue"><Profile>click</Profile></Nav>;

// 输出（JavaScript）：
const app = React.createElement(
  Nav,
  {color:"blue"},
  React.createElement(Profile, null, "click")
);
通过 JSX 创建的虚拟元素最终会被编译成调用 React 的 createElement 方法。那么 createElement 方法到底做了什么，它的奥秘是什么呢？我们来解读相关源码（源码路径：/v15.0.0/src/isomorphic/classic/element/ReactElement.js）：

// createElement 只是做了简单的参数修正，返回一个 ReactElement 实例对象，
// 也就是虚拟元素的实例
ReactElement.createElement = function(type, config, children) {
  // 初始化参数
  var propName;
  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  // 如果存在 config，则提取里面的内容
  if (config != null) {
    ref = config.ref === undefined ? null : config.ref;
    key = config.key === undefined ? null : '' + config.key;
    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // 复制 config 里的内容到 props（如 id 和 className 等）
    for (propName in config) {
      if (config.hasOwnProperty(propName) &&
          !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // 处理 children，全部挂载到 props 的 children 属性上。如果只有一个参数，直接赋值给 children，
  // 否则做合并处理
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // 如果某个 prop 为空且存在默认的 prop，则将默认 prop 赋给当前的 prop
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (typeof props[propName] === 'undefined') {
        props[propName] = defaultProps[propName];
      }
    }
  }

  // 返回一个 ReactElement 实例对象
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};
Virtual DOM 模型通过 createElement 创建虚拟元素，那又是如何创建组件的呢？

3.2.2　初始化组件入口

当使用 React 创建组件时，首先会调用 instantiateReactComponent，这是初始化组件的入口函数，它通过判断 node 类型来区分不同组件的入口。

当 node 为空时，说明 node 不存在，则初始化空组件 ReactEmptyComponent.create(instantiateReactComponent)。

当 node 类型为对象时，即是 DOM 标签组件或自定义组件，那么如果 element 类型为字符串时，则初始化 DOM 标签组件 ReactNativeComponent.createInternalComponent(element)，否则初始化自定义组件 ReactCompositeComponentWrapper()。

当 node 类型为字符串或数字时，则初始化文本组件 ReactNativeComponent.createInstanceForText(node)。

如果是其他情况，则不作处理。

instantiateReactComponent 函数关系如图 3-4 所示。

{%}

图 3-4　instantiateReactComponent 函数关系

instantiateReactComponent方法的源码如下（源码路径：/v15.0.0/src/renderers/shared/reconciler/instantiateReactComponent.js）：

// 初始化组件入口
function instantiateReactComponent(node, parentCompositeType) {
  var instance;

  // 空组件（ReactEmptyComponent）
  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  }

  if (typeof node === 'object') {
    var element = node;
    if (typeof element.type === 'string') {
      // DOM标签（ReactDOMComponent）
      instance = ReactNativeComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // 不是字符串表示的自定义组件暂无法使用，此处将不做组件初始化操作
      instance = new element.type(element);
    } else {
      // 自定义组件（ReactCompositeComponent）
      instance = new ReactCompositeComponentWrapper();
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    // 字符串或数字（ReactTextComponent）
    instance = ReactNativeComponent.createInstanceForText(node);
  } else {
    // 不做处理
  }

  // 设置实例
  instance.construct(node);
  // 初始化参数
  instance._mountIndex = 0;
  instance._mountImage = null;

  return instance;
}
3.2.3　文本组件

当 node 类型为文本节点时是不算 Virtual DOM 元素的，但 React 为了保持渲染的一致性，将其封装为文本组件 ReactDOMTextComponent。

在执行 mountComponent 方法时，ReactDOMTextComponent 通过 transaction.useCreateElement 判断该文本是否是通过 createElement 方法创建的节点，如果是，则为该节点创建相应的标签和标识 domID，这样每个文本节点也能与其他 React 节点一样拥有自己的唯一标识，同时也拥有了 Virtual DOM diff 的权利。但如果不是通过 createElement 创建的文本，React 将不再为其创建 <span> 和 domID 标识，而是直接返回文本内容。

不再为裸露的文本内容包裹 <span> 标签，是 React 15.0 版本的更新点之一。此前，React 为裸露的文本内容包裹上 <span> 标签，其实并没有产生任何作用，反而增加了不必要的标签，因此 React 15.0 版本将去掉这些操作。

在执行 receiveComponent 方法时，可以通过 DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText) 来更新文本内容。

ReactTextComponent 关系如图 3-5 所示。

{%}

图 3-5　ReactTextComponent 关系

ReactDOMTextComponent 的源码（源码路径：/v15.0.0/src/renderers/dom/shared/ReactDOMTextComponent.js）如下：

// 创建文本组件，这是 ReactText，并不是 ReactElement
var ReactDOMTextComponent = function(text) {
  // 保存当前的字符串
  this._currentElement = text;
  this._stringText = '' + text;

  // ReactDOMComponentTree 需要使用的参数
  this._nativeNode = null;
  this._nativeParent = null;

  // 属性
  this._domID = null;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

Object.assign(ReactDOMTextComponent.prototype, {
  mountComponent: function(transaction, nativeParent, nativeContainerInfo, context) {
    var domID = nativeContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._nativeParent = nativeParent;

    // 如果使用 createElement 创建文本标签，则该文本会带上标签和 domID
    if (transaction.useCreateElement) {
      var ownerDocument = nativeContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
      // 开始标签
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
      // 如果是文本类型，则创建文本节点
      if (this._stringText) {
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode
          (this._stringText)));
      }
      // 结束标签
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
      ReactDOMComponentTree.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);
      // 静态页面下直接返回文本
      if (transaction.renderToStaticMarkup) {
        return escapedText;
      }
      // 如果不是通过 createElement 创建的文本，则将标签和属性注释掉，直接返回文本内容
      return (
        '<!--' + openingValue + '-->' + escapedText +
        '<!--' + closingValue + '-->'
      );
    }
  },

  // 更新文本内容
  receiveComponent: function(nextComponent, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        this._stringText = nextStringText;
        var commentNodes = this.getNativeNode();

        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1],
          nextStringText);
      }
    }
  },
});
3.2.4　DOM 标签组件

Virtual DOM 模型涵盖了几乎所有的原生 DOM 标签，如 <div>、<p>、<span> 等。当开发者使用 React 时，此时的 <div> 并不是原生 <div> 标签，它其实是 React 生成的 Virtual DOM 对象，只不过标签名称相同罢了。React 的大部分工作都是在 Virtual DOM 中完成的，对于原生 DOM 而言，Virtual DOM 就如同一个隔离的沙盒，因此 React 的处理并不是直接操作和污染原生 DOM，这样不仅保持了性能上的高效和稳定，而且降低了直接操作原生 DOM 而导致错误的风险。

ReactDOMComponent 针对 Virtual DOM 标签的处理主要分为以下两个部分：

属性的更新，包括更新样式、更新属性、处理事件等；

子节点的更新，包括更新内容、更新子节点，此部分涉及 diff 算法。

1. 更新属性

当执行 mountComponent 方法时，ReactDOMComponent 首先会生成标记和标签，通过 this.createOpenTagMarkupAndPutListeners(transaction) 来处理 DOM 节点的属性和事件。

如果存在事件，则针对当前的节点添加事件代理，即调用 enqueuePutListener(this, propKey, propValue, transaction)。

如果存在样式，首先会对样式进行合并操作 Object.assign({}, props.style)，然后通过 CSSPropertyOperations.createMarkupForStyles(propValue, this) 创建样式。

通过 DOMPropertyOperations.createMarkupForProperty(propKey, propValue) 创建属性。

通过 DOMPropertyOperations.createMarkupForID(this._domID) 创建唯一标识。

_createOpenTagMarkupAndPutListeners 方法的源码如下（源码路径：/v15.0.0/src/renderers/dom/shared/ReactDOMComponent.js）：

_createOpenTagMarkupAndPutListeners: function(transaction, props) {
  var ret = '<' + this._currentElement.type;
  // 拼凑出属性
  for (var propKey in props) {
    var propValue = props[propKey];

    if (registrationNameModules.hasOwnProperty(propKey)) {
      // 针对当前的节点添加事件代理
      if (propValue) {
        enqueuePutListener(this, propKey, propValue, transaction);
      }
    } else {
      if (propKey === STYLE) {
        if (propValue) {
          // 合并样式
          propValue = this._previousStyleCopy = Object.assign({}, props.style);
        }
        propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
      }
      // 创建属性标识
      var markup = null;
      if (this._tag != null && isCustomComponent(this._tag, props)) {
        markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
      }
      if (markup) {
        ret += ' ' + markup;
      }
    }
  }

  // 对于静态页面，不需要设置 react-id，这样可以节省大量字节
  if (transaction.renderToStaticMarkup) {
    return ret;
  }

  // 设置 react-id
  if (!this._nativeParent) {
    ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
  }
  ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);

  return ret;
}
注意　去除 data-reactid 是 React 15.0 的更新点之一。众所周知，React 渲染后的每个 DOM 节点都会添加 data-reactid 属性。这个作为 DOM 节点的唯一标识而存在的字符串，不仅对用户毫无用处，而且还会存在一定的性能影响。因为当 DOM 更新时，每个节点的 data-reactid 属性也会进行更新，而更新 DOM 节点属性是需要部分性能消耗的。其实，早有开发者向 React 官方提过问题，建议去掉这个鸡肋的属性标识，这终于在 React 15.0 版本上实现了。据官方宣称，去除 data-reactid 使得 React 性能有了 10% 的提升。
当执行receiveComponent方法时，ReactDOMComponent会通过this.updateComponent(transaction, prevElement, nextElement, context) 来更新 DOM 节点属性。

先是删除不需要的旧属性。如果不需要旧样式，则遍历旧样式集合，并对每个样式进行置空删除；如果不需要事件，则将其事件监听的属性去掉，即针对当前的节点取消事件代理 deleteListener(this, propKey)；如果旧属性不在新属性集合里时，则需要删除旧属性 DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey)。

再是更新新属性。如果存在新样式，则将新样式进行合并 Object.assign({}, nextProp)；如果在旧样式中但不在新样式中，则清除该样式；如果既在旧样式中也在新样式中，且不相同，则更新该样式 styleUpdates[styleName] = nextProp[styleName]；如果在新样式中，但不在旧样式中，则直接更新为新样式 styleUpdates = nextProp；如果存在事件更新，则添加事件监听的属性 enqueuePutListener(this, propKey, nextProp, transaction)；如果存在新属性，则添加新属性，或者更新旧的同名属性DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp)。

至此，ReactDOMComponent 完成了 DOM 节点属性更新的操作，相关代码如下：

_updateDOMProperties: function(lastProps, nextProps, transaction) {
  var propKey;
  var styleName;
  var styleUpdates;

  // 当一个旧的属性不在新的属性集合里时，需要删除
  for (propKey in lastProps) {
    // 如果新属性里有，或者 propKey 是在原型上的则直接跳过，这样剩下的都是不在新属性集合里的，
    // 需要删除
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey]
      == null) {
      continue;
    }
    // 从 DOM 上删除不需要的样式
    if (propKey === STYLE) {
      var lastStyle = this._previousStyleCopy;
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          styleUpdates = styleUpdates || {};
          styleUpdates[styleName] = '';
        }
      }
      this._previousStyleCopy = null;
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // 这里的事件监听的属性需要去掉监听，针对当前的节点取消事件代理
         deleteListener(this, propKey);
        }
    } else if (DOMProperty.isStandardName[propKey] || DOMProperty.isCustomAttribute(propKey)) {
      // 从 DOM 上删除不需要的属性
      DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      );
    }
  }

  // 对于新的属性，需要写到 DOM 节点上
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp =
        propKey === STYLE ? this._previousStyleCopy :
        lastProps != null ? lastProps[propKey] : undefined;
    // 不在新属性中，或与旧属性相同，则跳过
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp
      == null) {
      continue;
    }
    // 在 DOM 上写入新样式（更新样式）
    if (propKey === STYLE) {
      if (nextProp) {
        nextProp = this._previousStyleCopy = Object.assign({}, nextProp);
      }
      if (lastProp) {
        // 在旧样式中且不在新样式中，清除该样式
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp
            || !nextProp.hasOwnProperty(styleName))) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        // 既在旧样式中也在新样式中，且不相同，更新该样式
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // 不存在旧样式，直接写入新样式
        styleUpdates = nextProp;
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp) {
        // 添加事件监听的属性
        enqueuePutListener(this, propKey, nextProp, transaction);
      } else {
        deleteListener(this, propKey);
      }
    // 添加新的属性，或者是更新旧的同名属性
    } else if (isCustomComponent(this._tag, nextProps)) {
      if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
        // setValueForAttribute 更新属性
        DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
      }
    } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
      var node = getNode(this);
      if (nextProp != null) {
        DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
      } else {
        // 如果更新为 null 或 undefined，则执行删除属性操作
        DOMPropertyOperations.deleteValueForProperty(node, propKey);
      }
    }
    // 如果 styleUpdates 不为空，则设置新样式
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  }
}
2. 更新子节点

当执行 mountComponent 方法时，ReactDOMComponent 会通过 this._createContentMarkup(transaction, props, context) 来处理 DOM 节点的内容。

首先，获取节点内容 props.dangerouslySetInnerHTML。如果存在子节点，则通过 this.mountChildren(childrenToUse, transaction, context) 对子节点进行初始化渲染：

_createContentMarkup: function(transaction, props, context) {
  var ret = '';

  // 获取子节点渲染出的内容
  var innerHTML = props.dangerouslySetInnerHTML;

  if (innerHTML != null) {
    if (innerHTML.__html != null) {
      ret = innerHTML.__html;
    }
  } else {
    var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
    var childrenToUse = contentToUse != null ? null : props.children;

    if (contentToUse != null) {
      ret = escapeTextContentForBrowser(contentToUse);
    } else if (childrenToUse != null) {
      // 对子节点进行初始化渲染
      var mountImages = this.mountChildren(childrenToUse, transaction, context);

      ret = mountImages.join('');
    }
  }
  // 是否需要换行
  if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
    return '\n' + ret;
  } else {
    return ret;
  }
}
当执行 receiveComponent 方法时，ReactDOMComponent 会通过 this._updateDOMChildren(lastProps, nextProps, transaction, context) 来更新 DOM 内容和子节点。

先是删除不需要的子节点和内容。如果旧节点存在，而新节点不存在，说明当前节点在更新后被删除，此时执行方法 this.updateChildren(null, transaction, context)；如果旧的内容存在，而新的内容不存在，说明当前内容在更新后被删除，此时执行方法 this.updateTextContent('')。

再是更新子节点和内容。如果新子节点存在，则更新其子节点，此时执行方法 this.updateChildren(nextChildren, transaction, context)；如果新的内容存在，则更新内容，此时执行方法 this.updateTextContent('' + nextContent)。

至此，ReactDOMComponent 完成了 DOM 子节点和内容的更新操作，相关代码如下：

_updateDOMChildren: function(lastProps, nextProps, transaction, context) {
  // 初始化
  var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
  var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
  var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
  var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

  var lastChildren = lastContent != null ? null : lastProps.children;
  var nextChildren = nextContent != null ? null : nextProps.children;
  var lastHasContentOrHtml = lastContent != null || lastHtml != null;
  var nextHasContentOrHtml = nextContent != null || nextHtml != null;

  if (lastChildren != null && nextChildren == null) {
    // 旧节点存在，而新节点不存在，说明当前节点在更新后被删除了
    this.updateChildren(null, transaction, context);
  } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
    // 说明当前内容在更新后被删除了
    this.updateTextContent('');
  }

  // 新节点存在
  if (nextContent != null) {
    // 更新内容
    if (lastContent !== nextContent) {
      this.updateTextContent('' + nextContent);
    }
  } else if (nextHtml != null) {
    // 更新属性标识
    if (lastHtml !== nextHtml) {
      this.updateMarkup('' + nextHtml);
    }
  } else if (nextChildren != null) {
    // 更新子节点
    this.updateChildren(nextChildren, transaction, context);
  }
}
当卸载组件时，ReactDOMComponent 会进行一系列的操作，如卸载子节点、清除事件监听、清空标识等：

unmountComponent: function(safely) {
  this.unmountChildren(safely);
  ReactDOMComponentTree.uncacheNode(this);
  EventPluginHub.deleteAllListeners(this);
  ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
  this._rootNodeID = null;
  this._domID = null;
  this._wrapperState = null;
}
ReactDOMComponent 关系如图 3-6 所示。

{%}

图 3-6　ReactDOMComponent关系

其中，updateChildren 为 diff 中的内容，请移步至 3.5 节。

3.2.5　自定义组件

ReactCompositeComponent 自定义组件实现了一整套 React 生命周期和 setState 机制，因此自定义组件是在生命周期的环境中进行更新属性、内容和子节点的操作。这些更新操作与 ReactDOMComponent 的操作类似，在此就不赘述了。

如果对 React 生命周期机制不了解，下一节就可以让你深入了解生命周期的管理艺术。

ReactCompositeComponent 关系如图 3-7 所示。

图像说明文字

图 3-7　ReactCompositeComponent 关系

